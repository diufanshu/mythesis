% !Mode:: "TeX:UTF-8"
% !TEX root = ..\thesis.tex
\newcommand{\jobunit}[1]{*+[F]{\makebox[1.5em]{$#1$}}}
\newcommand{\process}[1]{*++=[o][F]{\makebox[2em]{$#1$}}}
\chapter{算法设计}
上一章构建了$2$个多品种产品调度的数学模型，需要对其检验，而这些模型求解是NP--Hard问题，需要设计相应算法来求解。在求解模型前，需要对订单处理时间计算，该问题也需通过算法设计求解。模型的具体求解算法可以分为构造型和改进型，前者从没有调度的情况开始，按一定分派规则逐渐安排作业，直至生成一个较好的调度；后者则是在前者的基础上，调整已有调度以改善目标。
\section{处理时间函数}
前一章提到，各订单的处理时间与被处理的流水线无关，只与其所含作业数量相关，因此可将订单的处理时间看作是关于订单本身及其所含作业数量的函数，记为$p_j = g(j,n_j)$，其中$n_j$为订单$j$所含的作业数量。此外，仍需要补充符号说明如下：\\[3pt]
\begin{supertabular}{ll}
$n_j$ & 订单$j$所含的作业数量\\
$k$ & 作业标记，$k = 1,2,...,n_j$\\
$m_j$ & 订单$j$的处理单元数量\\
$i$ & 订单$j$的处理单元标记，$i = 1,2,...,m_j$\\
$q_{k,i}$ & 作业$k$在处理单元$i$上的处理时间\\
$c_{k,i}$ &作业$k$的在处理单元$i$上的完成时刻\\
$c_{j,\max}$ & 订单$j$中所有作业的制造期，即$\max(c_k)$\\
\end{supertabular}\\[3pt]
其中不同作业在同处理单元上的处理时间相同，可以简记为$q_i$。

由于订单和子单仅有作业数量的差别，故考虑订单的情况即可推广到子单。由于，产品体积小，可以假设处理单元间的缓冲空间足够用。订单在某条流水线上的作业可以看作是流水车间环境，没有换线时间，所以该问题可以记为：$Fm\mid \mid C_{\max}$，显而易见的是 $c_{j,\max} = c_{n_j,m_j}$。该问题的数学模型如下：
\begin{gather}
\min c_{n_j, m_j}\\[-2pt]
\text{s.t.}\notag
\end{gather}
\begin{numcases}{}
c_{1,1} = q_{1,1}\label{equ:processtime1}\\
c_{1,i} = \sum_{i=1}^{m_j} q_{1,i}\label{equ:processtime2}\\
c_{k,1} = c_{k-1,1} + q_{k,1} & $k = 2,3,...,n_j$\\
c_{k,i} = \max\{c_{k-1,i} ,c_{k,i-1}\} &$k = 2,3,...,n_j, i = 2,3,...,m_j$\\
q_{k,i}  = q_i & $k = 1,2,...,n_j, i = 1,2,...,m_j$
\end{numcases}

该问题可以用有向图来表示，其关键路径即为所求解的计算历程。如\ref{fig:directedgraph}所示，每个节点内表示作业的处理时间，横向表示作业处理顺序，纵向表示不同的处理单元，由左上角开始，按照有向弧的方向进入节点，计算出右下节点的时间即为订单处理时间。
其中，\eqref{equ:processtime1}和(\ref{equ:processtime2})可以化简得到这个等式：$c_{k,1} = k\cdot q_1,(k = 1,2,...,n)$，便于下面算法的初始化。
\begin{figure}[h]
\begin{equation*}
\xymatrix{
\process{q_{1,1}} \ar[r] \ar[d] & \process{q_{1,2}} \ar[d] \ar[r] & \cdots\ar[r] & \process{q_{1,m_j}} \ar[d]\\
\process{q_{2,1}} \ar[r]\ar[d] & \process{q_{2,2}} \ar[d]\ar[r] & \cdots \ar[r] \ar[d]& \process{q_{2,m_j}} \ar[d] \\
\vdots\ar[d] & \vdots \ar[d]\ar[r] & \process{q_{k,i}}\ar[r]\ar[d] &\vdots \ar[d]\\
\process{q_{n_j,1}} \ar[r] & \process{q_{n_j,2}} \ar[r] & \cdots\ar[r] & \process{q_{n_j,m_j}}
}
\end{equation*}
\caption{订单的作业处理有向图\label{fig:directedgraph}}
\end{figure}

\newcounter{algor}%\newcounter{exam}
\theoremheaderfont{\heiti}
\newtheorem{algori}[algor]{算法}%\newtheorem{exam}[exam]{示例}
\begin{algori}
处理时间函数值生成算法\label{alg:processtime}

\begin{asparaenum}
\renewcommand{\labelenumi}{\bf Step\theenumi~}
\item 初始化，输入作业数量$n$和所需处理单元数量$m$，然后输入各单元处理时间$q_1,q_2,...,q_m$；
\item 计算$c_{k,1} = k\cdot q_1,(k = 1,2,...,n)$，记$i = 1$；
\item $i = i + 1, c_{1,i} = c_{1,i-1} + q_i$，记$k = 1$；
\item $k = k + 1, c_{k,i} = \max\{c_{k,i-1}, c_{k-1,i}\} + q_i$；
\item 如果$k<n$，执行\Step{3}，否则执行\Step{5}；
\item 如果$i<m$，执行\Step{2}，否则结束算法。
\end{asparaenum}
\end{algori}

\section{分派规则}
前文已提到的EDD规则和FCFS规则是常见的调度分派规则，在具体调度作业的时候，通常会先根据分派规则进行安排，所以分派规则便是作业安排的初始策略，然后再局部调整调度方案以进一步优化。一个周详的规则可能得到最优调度的初始解，显然简化了局部调整过程，然而极可能会需要巨大的思考空间和时间(比如枚举)。同样，过于直觉的规则将会增大后续调整的难度，所以制定分派规则时要作权衡。
\subsection{基本规则}
\begin{asparaenum}
\item EDD(最早交货期)
\suspend{asparaenum}

EDD规则从工期角度出发，将作业按照交货时刻的先后进行排序，并按这个顺序进行生产处理。对于并行机环境，一旦某处理单元空闲，就可以即刻安排队列中的首个作业任务。这个规则适用于安排目标和工期相关的调度任务。
\resume{asparaenum}
\item WSPT(加权最短处理时间)
\suspend{asparaenum}

WSPT规则是SPT(最短处理时间)规则的一般化，从作业的处理时间出发，对以完工时刻为目标的调度任务较为合适。这个规则将处理作业按照$w_j/p_j$值非增的顺序排列，处理时间较长的作业被安排在较后的位置，从一定程度上减少了排队等待时间，并且可以证明WSPT规则对$1\mid \mid \sum w_jC_j$的调度是最优的\cite{pinedo}，然而在$Pm \mid \mid \sum w_jC_j$ 环境下并不一定是最优。

\resume{asparaenum}
\item MS(最小松弛)
\end{asparaenum}

MS规则通过描述作业的紧迫程度来进行作业调度，与前两者最大的区别在于，这个规则是动态的，即和系统时间$t$相关。作业根据$\max \{d_j - p_j - t , 0\}$的值非减的顺序排列，显然较为紧迫的作业会被安排在前面，并且不同的系统时间会影响排列的顺序，呈现动态的调度。该规则适用于安排目标和工期相关的调度任务。
\subsection{复合规则}
复合分派规则是综合了许多基本规则的一个表达式，各基本规则都有其各自的比例参数，用来确定这个规则对符合规则影响程度的比例，没有固定的形式，接下来举一例：ATC(明显滞后成本)规则。

ATC规则综合了WSPT规则和MS规则，每当有空闲处理单元时，所有待调度作业按\eqref{equ:orderindexexample}计算其排序指数，选出具有最大指数值的作业进行处理。
\begin{equation}
I_j(t) = \frac{w_j}{p_j}\exp\left(-\frac{\max\{d_j - p_j - t, 0\}}{K\bar p}\right) \label{equ:orderindexexample}
\end{equation}
式中：

\begin{tabular}{ll}
$K$ & 规则比例参数\\
$\bar p$ &剩余作业平均处理时间
\end{tabular}

可以看出当$K \to \infty$时，$I_j(t) \to w_j/p_j$，此时ATC规则便转化为WSPT规则。当$K \to 0$时，若作业$j$将产生延期，即$\max(d_j - p_j -t , 0 ) = 0$，那么ATC规则也转化为WSPT规则，若作业不会产生延期，由于$d_j - p_j - t$的影响超过$w_j/p_j$，规则ATC将转化为MS规则。ATC规则可以较容易地应用到$Pm\mid\mid \sum w_jT_j$问题，其关键技术在于比例参数$K$的选取。

\section{基本模型}
基本模型由目标函数\eqref{equ:objmain}和约束条件\eqref{equ:basicst1} -- (\ref{equ:basicst7})组成，其最优调度的求解包括初始可行解与解的改进，分别在构造型和改进型算法中详述。
\subsection{构造算法}
构造算法的主要内容是确定分派规则，虽然不能保证得到最优调度，但却有着很高的执行性，便于计划安排。基本模型的目标函数主要成分是为加权时延迟间总和，采用ATC规则能得到较优调度\footnote{准确来说，ATC规则较为适用于$1\mid\mid \sum w_jT_j$ 问题，对于$Pm\mid\mid \sum w_jT_j$也能得到质量很高的解，虽然这个规则运用于基本模型所涉及的问题效果不一定如这两个确切的问题，但足够作为后续改进的初始调度}，关键在于比例参数的选取，相关的方法也有很多，例如回归分析、机器学习等。本课题将该规则得到的调度作为改进算法的初始解，所以不需要在该参数上过多深究，可以采用$K = 2$作为推荐值\cite{bilge2007tabu}。

针对基本模型的实际情况，调度中的作业为各订单，并用整合处理时间作为各订单的处理时间，这样可以不考虑切换准备时间。此外，后续的改进算法要用到构造算法的相关信息，需要记录被调度的订单序列。为了方便描述这个算法以及后续算法，需要扩充符号说明如下：针对基本模型的实际情况，调度中的作业为各订单，并用整合处理时间作为各订单的处理时间，这样可以不考虑切换准备时间。此外，后续的改进算法要用到构造算法的相关信息，需要记录被调度的订单序列。为了方便描述这个算法以及后续算法，需要扩充符号说明如下：针对基本模型的实际情况，调度中的作业为各订单，并用整合处理时间作为各订单的处理时间，这样可以不考虑切换准备时间。此外，后续的改进算法要用到构造算法的相关信息，需要记录被调度的订单序列。为了方便描述这个算法以及后续算法，需要扩充符号说明如下：

\begin{supertabular}{ll}
$J$ & 待调度订单集合\\
$L$ & 已调度的订单记录序列，其集合记为$\overline{L}$\\
$a_l$ & 流水线运行状态，处理订单时$a_l = 1$，否则$a_l = 0$，$(l = 1,2,...,m)$\\
$t_l$ & 流水线$l$的预计正在处理订单的完成时刻，$(l = 1,2,...,m)$\\
$G(S)$& 调度$S$的目标函数\\
$H(S_l)$ & 流水线$l$的调度目标函数\\
$h(j)$ & 订单$j$的目标函数\\
$S^{(0)}$ & 目前为止的最佳调度\\
$S^{(c)}$& 相邻调度，即候选调度\\
$TL$ & 禁忌列表\\
$NL$ &禁忌列表长度\\
$A$ & 特赦解\\
$NR$ &交替次数\\
\end{supertabular}

\begin{algori}
基本模型ATC规则调度构造算法\label{alg:basicconstruct}

\begin{asparaenum}
\renewcommand{\labelenumi}{\bf Step\theenumi~}
\item 初始化。$J = N, \overline{L} = \varnothing$, $t_l = 0, \overline{S_l} = \varnothing, a_l=0 (l = 1,2,...,m)$，根据和\refa{alg:processtime}计算各订单处理时间$p'_j = g(j, n_j)$，进一步得到整合订单处理时间$p_j = p'_j + s_j, (j = 1,2,...,n)$，置系统时间$t = 0$；
\item 若存在$a_l = 0$，记$l^* = \displaystyle\min_{a_l = 0}\{l\}$，执行\Step{3}，否则执行\Step{4}；
\item 根据\eqref{equ:orderindexexample}，选取预备调度订单$j^*$，使得$I_{j^*}(t) = \displaystyle\max_{j\in J}\{I_j(t)\}$，将订单$j^*$安排入流水线$l^*$进行处理，记入调度$S_{l^*}$，$\overline{S_{l^*}}=\overline{S_{l^*}}\bigcup \{j^*\}$, $J = J -\{j^*\}$，记录调度订单序列$\overline{L} = \overline{L} \bigcup \{j^*\}$，更新流水线预计空闲时刻$t_{l^*} = t + p_{j^*}$，修改流水线状态$a_{l^*} = 1$。若$J = \varnothing$，所有订单调度完毕，终止算法，否则执行\Step{2}
\item 记$lt$使得 $t_{lt} = \displaystyle\min_{1\le l\le m}\{t_l\}$，修改流水线状态$a_{lt} = 0$，并更新系统时间$t = t_{lt}$，执行\Step{2}
\end{asparaenum}
\end{algori}

\subsection{改进算法}
构造算法得到的初始解需要进行改进，为了尽可能得到较优解，需要采用一些启发式(元启发式)算法，区域搜索是一类较为有效并且操作简便的算法，其主要的两个步骤是邻域的定义与移动选择。对于多机环境，一般采用分阶段的交替算法。此外，本文提出的一种虚拟序列算法克服了交替算法的一些劣势。

\subsubsection{邻域定义}
为了后面相关算法的描述，需要先定义邻域。考虑第一种情况，某机器上有共$4$项作业(标记为$1,2,3,4$)，其初始调度$S^{(1)}$安排如\reff{fig:4example}所示，
\begin{figure}[h]
\begin{equation*}
\xymatrix{
\jobunit{1} \ar[r] & \jobunit{2} \ar[r] &\jobunit{3} \ar[r] &\jobunit{4}
}
\end{equation*}
\caption{$4$项作业的初始调度$S^{(1)}$示例\label{fig:4example}}
\end{figure}
箭头方向为作业处理的顺序方向。交换$S^{(1)}$中相邻两项作业的顺序，可以得到一个新的调度$S^{(2)}$，显然此例中$S^{(2)}$有如\reff{fig:3neighbors}所示的$3$种可能。这三个不同的调度构成了调度$S^{(1)}$的邻域，而确定其中的一个作为$S^{(2)}$便是一次移动选择。至此，机器内的邻域及移动定义完毕。

\begin{figure}[h]
\centering
\vspace{1.5em}
\subfloat[交换$1,2$]{
\xymatrix{
\jobunit{2} \ar[r] & \jobunit{1} \ar[r] &\jobunit{3} \ar[r] &\jobunit{4}
}}\\
\subfloat[交换$2,3$]{
\xymatrix{
\jobunit{1} \ar[r] & \jobunit{3} \ar[r] &\jobunit{2} \ar[r] &\jobunit{4}
}}\\
\subfloat[交换$3,4$]{
\xymatrix{
\jobunit{1} \ar[r] & \jobunit{2} \ar[r] &\jobunit{4} \ar[r] &\jobunit{3}
}}
\caption{$S^{(1)}$的$3$个相邻调度\label{fig:3neighbors}}
\end{figure}

接下来考虑另一种情况，在多机环境下，机器间的作业移动。如果只是简单的从某个机器上挑选某个作业移动到另一个机器的某个位置，这样定义的邻域容量约为$2\sum\sum n_i\times n_j$，($n_i,n_j$为机器$i,j$上的作业数量)，不但会和前一种情况的邻域重叠，其过大的容量对搜索来说也是不合理的。所以机器间的邻域及移动要按照具体情况来设计定义。

\subsubsection{交替算法}
通常并行机环境的改进算法分为两个阶段，机器内部的作业序列改变和机器间的作业改派，这两个过程交替进行\cite{史烨2011}，然而这个方法十分费时，但简化内部改进则又影响解的质量。本节将提出一种新的邻域结构，巧妙地避免了前面的问题。
一般来说，由ATC规则所得到的该模型的初始解是较优解，甚至可能是最优解，如果需要对其改进，需要从两个方面来考虑。一个是流水线内部订单序列的调整，另一个是流水线间的订单调整，这两种调整涉及两种元启发式算法，需要交替使用。
\begin{asparaenum}
\item 内部调整
\suspend{asparaenum}

流水线内部调整可将作是$1\mid\mid \sum w_jT_j$问题，可以简单运用ATC规则达到较好解，不同与前面的并行机环境，单机环境下，对流水线$l$使用ATC调度作业的具体算法如下。

\begin{algori}
基本模型ATC规则调度改进算法
\begin{asparaenum}
\renewcommand{\labelenumi}{\bf Step\theenumi~}
\item 初始化。$J = \overline{S_l}$，根据和\refa{alg:processtime}计算各订单处理时间$p'_{l_k} = g({l_k}, |S_l|)$，进一步得到整合订单处理时间$p_{l_k} = p'_{l_k} + s_{l_k}(k = 1,2,...,|S_l|)$，置系统时间$t = 0$；
%\item 若$a_l = 0$，执行\Step{3}，否则执行\Step{4}；
\item 根据\eqref{equ:orderindexexample}，选取预备调度订单$l_k^*$，使得$I_{l_k^*}(t) = \displaystyle\max_{l_k\in J}\{I_{l_k}(t)\}$，将订单$l_k^*$进行安排处理，$J = J -\{l_k^*\}$，更新流水线预计空闲时刻$t_{l} = t + p_{l_k^*}$，修改流水线状态$a_{l} = 1$。若$J = \varnothing$，该流水线上的订单调度完毕，终止算法，否则执行\Step{3}；
\item 更新系统时间$t = t + p_{l_k^*}$，执行\Step{2}。
\end{asparaenum}
\end{algori}

也可以对流水线$l$采用区域搜索的方法改进进行，该流水线上的调度邻域和前面的机器内部邻域类似，作业的序列就相当于流水线上订单的序列，初始调度$S_l^{(1)}$由\refa{alg:basicconstruct}得到，如\reff{fig:initlschedule}所示。
\begin{figure}[h]
\begin{equation*}
\xymatrix{
\jobunit{l_1} \ar[r] & \jobunit{l_2} \ar[r]& \jobunit{l_3} \ar[r]&\cdots\ar[r] &\jobunit{l_{|S_l|}}
}
\end{equation*}
\caption{流水线的初始调度$S_l^{(1)}$\label{fig:initlschedule}}
\end{figure}
这样一来，对于每条流水线的内部调整改进，每次生成的调度都有$|S_l|-1$个相邻的调度可供移动，并以相邻订单对$(l_j, l_k)$来表示解的一次移动。若每次都向着目标值改进最大的方向移动，则可能陷入局部最优解。可以采用一些机制避免此类情况发生，不同的机制原理便产生了不同的元启发式搜索算法。根据基本模型的特征，本文将采用改进过的禁忌所搜算法，它的机理是在移动选择时，为了不落入局部最优的循环而有意识地避开，需要设定禁忌列表$TL$及其长度$NL$，通常禁忌列表满时候，采用FIFO规则将项目出栈。基本模型下，流水线$l$的内部调整禁忌搜索总结如下。
\begin{algori}
基本模型内部调整禁忌搜索算法
\begin{asparaenum}
\renewcommand{\labelenumi}{\bf Step\theenumi~}
\item 初始化。设定迭代次数$N_I$，清空禁忌列表$TL$，设定列表长度$NL$，将构造算法所得的调度作为初始调度，并记为当前最优调度，$S^{(0)} = S^{(1)} = S_l$，并置$k = 1$；
\item 从$S_k$所有不在禁忌列表中的相邻移动$(l_j,l_k)$中，所得调度具有最小函数值的移动，记为$(l_j^*, l_k^*)$，所得调度记为$S^{(c)}$，并置$S^{(k+1)} = S^{(c)}$；
\item 将相邻移动$(l_j^*, l_k^*)$入栈禁忌列表，若列表容量已满，则按FIFO规则出栈最早的相邻移动；
\item 若$G(S^{(c)}) < G(S^{(0)})$，置$S^{(0)} = S^{(c)}$；
\item 置$k = k + 1$，若$k\le N_I$，执行\Step{2}，否则终止算法。
\end{asparaenum}
\label{alg:intertabu}
\end{algori}

\resume{asparaenum}
\item 之间调整
\suspend{asparaenum}

前面的部分说明了流水线内的订单调度改进，然而即使所有流水线都按照其相应的最优调度进行生产处理，从全局来看，这样的调度安排未必就是最优，这主要是由流水线使用不均衡引起的，这种不均衡性只能通过流水线之间的订单交换或重派来改变。将流水线$a$上的订单$a_j$重新安排在流水线$b$上的操作称为\textbf{订单重派}，两流水线间的订单交换可以看作是这两条流水线互相订单重派。因此，全局调度关于流水线之间的相邻移动可以定义为某订单重派。

为提高流水线均衡性，订单重派策略为：从具有最大目标值$H(S_l)$的流水线中选取具有最大函数值$h(l_k)$的作业，将其重派至具有最小目标值的流水线上调度末端，因此需要定义流水线$l$的函数值与各订单的函数值，根据\eqref{equ:objmain}可得两函数值的定义：
\begin{align}
H(S_l) &= \lambda_t\sum_{k=1}^{|S_l|} wt_{l_k}T_{l_k} + \lambda_c\sum_{k=1}^{|S_l|}wc_{l_k}C_{l_k}\label{equ:linefunct}\\
h(l_k) &= \lambda_t wt_{l_k}T_{l_k} + \lambda_c wc_{l_k}C_{l_k}
\label{equ:itemfunct}
\end{align}
这个策略可以用一个确定性的算法得到。
\begin{algori}
流水线之间订单重派算法\label{alg:basicbetween}
\begin{asparaenum}
\renewcommand{\labelenumi}{\bf Step\theenumi~}
\item 根据\eqref{equ:linefunct}选出具有最大值与最小值的流水线，记为$l^+, l^-$；
\item 根据\eqref{equ:itemfunct}选出$S_{l^+}$中具有最大值的订单$l^+_{k^*}$，并将其添入流水线$l^-$的调度$S_{l^-}$末端。
\end{asparaenum}
\end{algori}

\resume{asparaenum}
\item 交替改进
\end{asparaenum} 

产生初始调度后，各流水线上的调度需要通过内部调整以局部改进，然后通过流水线之间的订单重派对现有解进行扰动，此时被添派订单的流水线则需要再调整一次以合理安排新添入的订单。如此交替操作便是这个算法的基本策略。
\begin{algori}
基本模型交替算法
\begin{asparaenum}
\renewcommand{\labelenumi}{\bf Step\theenumi~}
\item 运用\refa{alg:basicconstruct}建立流水线全局调度初始解；
\item 运用\refa{alg:intertabu}改进所有流水线的初始调度，设定交替次数$NR$，置$k = 1$；
\item 运用\refa{alg:basicbetween}重派订单，并将被派单的流水线记为$l^*$；
\item 运用\refa{alg:intertabu}对流水线$l^*$进行调整改进；
\item 置$k = k+1$，若$k\le NR$，执行\Step{3}，否则终止算法。
\end{asparaenum}
\end{algori}
\subsubsection{虚拟序列算法}
尽管\refa{alg:basicconstruct}得到了较优的调度，然而还可以通过元启发式算法(例如区域搜索)进一步改进，其关键步骤是邻域和交换的定义。

显而易见的是，由\refa{alg:basicconstruct}得到的调度，对于每条流水线来说，其处理的订单都按照ATC规则排序，若直接对其进行区域搜索，则是不全面的考虑。所以本节将对由前面构造算法得到的记录序列$L$进行邻域定义。



\section{陆续模型}
\subsection{构造算法}

\subsection{改进算法}


\section{小结}

tikz 作图
\begin{figure}[h]
\centering
\begin{tikzpicture}
\draw (0,0) rectangle (0.3,1.00);
\end{tikzpicture}
\end{figure}